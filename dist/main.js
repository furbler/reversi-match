/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/canvas2d.ts":
/*!*************************!*\
  !*** ./src/canvas2d.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Canvas2DUtility = void 0;\n/**\n * Canvas2D API をラップしたユーティリティクラス\n */\nclass Canvas2DUtility {\n    /**\n     * @constructor\n     * @param {HTMLCanvasElement} canvas - 対象となる canvas element\n     */\n    constructor(canvas) {\n        this.canvasElement = canvas;\n        this.context2d = canvas.getContext('2d');\n    }\n    /**\n     * @return {HTMLCanvasElement}\n     */\n    get canvas() { return this.canvasElement; }\n    /**\n     * @return {CanvasRenderingContext2D}\n     */\n    get context() { return this.context2d; }\n    /**\n     * 矩形を描画する\n     * @param {number} x - 塗りつぶす矩形の左上角の X 座標\n     * @param {number} y - 塗りつぶす矩形の左上角の Y 座標\n     * @param {number} width - 塗りつぶす矩形の横幅\n     * @param {number} height - 塗りつぶす矩形の高さ\n     * @param {string} [color] - 矩形を塗りつぶす際の色\n     */\n    drawRect(x, y, width, height, color) {\n        // 色が指定されている場合はスタイルを設定する\n        if (color != null) {\n            this.context2d.fillStyle = color;\n        }\n        this.context2d.fillRect(x, y, width, height);\n    }\n    // /**\n    //  * 線分を描画する\n    //  * @param {number} x1 - 線分の始点の X 座標\n    //  * @param {number} y1 - 線分の始点の Y 座標\n    //  * @param {number} x2 - 線分の終点の X 座標\n    //  * @param {number} y2 - 線分の終点の Y 座標\n    //  * @param {string} [color] - 線を描画する際の色\n    //  * @param {number} [width=1] - 線幅\n    //  * dash : trueで破線になる\n    //  */\n    drawLine(x1, y1, x2, y2, color, width = 1) {\n        // 色が指定されている場合はスタイルを設定する\n        if (color != null) {\n            this.context2d.strokeStyle = color;\n        }\n        // 線幅を設定する\n        this.context2d.lineWidth = width;\n        // パスの設定を開始することを明示する\n        this.context2d.beginPath();\n        // パスの始点を設定する\n        this.context2d.moveTo(x1, y1);\n        // 直線のパスを終点座標に向けて設定する\n        this.context2d.lineTo(x2, y2);\n        // パスを閉じることを明示する\n        this.context2d.closePath();\n        // 設定したパスで線描画を行う\n        this.context2d.stroke();\n    }\n    //破線を描画\n    drawDashLine(x1, y1, x2, y2, color, width = 1) {\n        // 色が指定されている場合はスタイルを設定する\n        if (color != null) {\n            this.context2d.strokeStyle = color;\n        }\n        // 線幅を設定する\n        this.context2d.lineWidth = width;\n        // パスの設定を開始することを明示する\n        this.context2d.beginPath();\n        //破線\n        this.context2d.setLineDash([20, 50]);\n        // パスの始点を設定する\n        this.context2d.moveTo(x1, y1);\n        // 直線のパスを終点座標に向けて設定する\n        this.context2d.lineTo(x2, y2);\n        // パスを閉じることを明示する\n        this.context2d.closePath();\n        // 設定したパスで線描画を行う\n        this.context2d.stroke();\n    }\n    /**\n     * 多角形を描画する\n     * @param {Array<number>} points - 多角形の各頂点の座標\n     * @param {string} [color] - 多角形を描画する際の色\n     */\n    drawPolygon(points, color) {\n        // points が配列であるかどうか確認し、多角形を描くために\n        // 十分な個数のデータが存在するか調べる\n        if (Array.isArray(points) !== true || points.length < 6) {\n            return;\n        }\n        // 色が指定されている場合はスタイルを設定する\n        if (color != null) {\n            this.context2d.fillStyle = color;\n        }\n        // パスの設定を開始することを明示する\n        this.context2d.beginPath();\n        // パスの始点を設定する\n        this.context2d.moveTo(points[0], points[1]);\n        // 各頂点を結ぶパスを設定する\n        for (let i = 2; i < points.length; i += 2) {\n            this.context2d.lineTo(points[i], points[i + 1]);\n        }\n        // パスを閉じることを明示する\n        this.context2d.closePath();\n        // 設定したパスで多角形の描画を行う\n        this.context2d.fill();\n    }\n    /**\n     * 円を描画する\n     * @param {number} x - 円の中心位置の X 座標\n     * @param {number} y - 円の中心位置の Y 座標\n     * @param {number} radius - 円の半径\n     * @param {string} [color] - 円を描画する際の色\n     * 塗りつぶしするかどうか\n     */\n    drawCircle(x, y, radius, color, fillCircle = true) {\n        // パスの設定を開始することを明示する\n        this.context2d.beginPath();\n        // 円のパスを設定する\n        this.context2d.arc(x, y, radius, 0.0, Math.PI * 2.0);\n        // パスを閉じることを明示する\n        this.context2d.closePath();\n        // 設定したパスで円の描画を行う\n        if (fillCircle) {\n            //図形内部を塗りつぶす\n            // 色が指定されている場合はスタイルを設定する\n            if (color != null)\n                this.context2d.fillStyle = color;\n            this.context2d.fill();\n        }\n        else {\n            //図形内部を塗りつぶさない\n            // 色が指定されている場合はスタイルを設定する\n            if (color != null)\n                this.context2d.strokeStyle = color;\n            this.context2d.stroke();\n        }\n    }\n    /**\n     * 扇形を描画する\n     * @param {number} x - 扇形を形成する円の中心位置の X 座標\n     * @param {number} y - 扇形を形成する円の中心位置の Y 座標\n     * @param {number} radius - 扇形を形成する円の半径\n     * @param {number} startRadian - 扇形の開始角\n     * @param {number} endRadian - 扇形の終了角\n     * @param {string} [color] - 扇形を描画する際の色\n     */\n    drawFan(x, y, radius, startRadian, endRadian, color) {\n        // 色が指定されている場合はスタイルを設定する\n        if (color != null) {\n            this.context2d.fillStyle = color;\n        }\n        // パスの設定を開始することを明示する\n        this.context2d.beginPath();\n        // パスを扇形を形成する円の中心に移動する\n        this.context2d.moveTo(x, y);\n        // 円のパスを設定する\n        this.context2d.arc(x, y, radius, startRadian, endRadian);\n        // パスを閉じることを明示する\n        this.context2d.closePath();\n        // 設定したパスで扇形の描画を行う\n        this.context2d.fill();\n    }\n    /**\n     * 線分を二次ベジェ曲線で描画する\n     * @param {number} x1 - 線分の始点の X 座標\n     * @param {number} y1 - 線分の始点の Y 座標\n     * @param {number} x2 - 線分の終点の X 座標\n     * @param {number} y2 - 線分の終点の Y 座標\n     * @param {number} cx - 制御点の X 座標\n     * @param {number} cy - 制御点の Y 座標\n     * @param {string} [color] - 線を描画する際の色\n     * @param {number} [width=1] - 線幅\n     */\n    drawQuadraticBezier(x1, y1, x2, y2, cx, cy, color, width = 1) {\n        // 色が指定されている場合はスタイルを設定する\n        if (color != null) {\n            this.context2d.strokeStyle = color;\n        }\n        // 線幅を設定する\n        this.context2d.lineWidth = width;\n        // パスの設定を開始することを明示する\n        this.context2d.beginPath();\n        // パスの始点を設定する\n        this.context2d.moveTo(x1, y1);\n        // 二次ベジェ曲線の制御点と終点を設定する\n        this.context2d.quadraticCurveTo(cx, cy, x2, y2);\n        // パスを閉じることを明示する\n        this.context2d.closePath();\n        // 設定したパスで線描画を行う\n        this.context2d.stroke();\n    }\n    /**\n     * 線分を三次ベジェ曲線で描画する\n     * @param {number} x1 - 線分の始点の X 座標\n     * @param {number} y1 - 線分の始点の Y 座標\n     * @param {number} x2 - 線分の終点の X 座標\n     * @param {number} y2 - 線分の終点の Y 座標\n     * @param {number} cx1 - 始点の制御点の X 座標\n     * @param {number} cy1 - 始点の制御点の Y 座標\n     * @param {number} cx2 - 終点の制御点の X 座標\n     * @param {number} cy2 - 終点の制御点の Y 座標\n     * @param {string} [color] - 線を描画する際の色\n     * @param {number} [width=1] - 線幅\n     */\n    drawCubicBezier(x1, y1, x2, y2, cx1, cy1, cx2, cy2, color, width = 1) {\n        // 色が指定されている場合はスタイルを設定する\n        if (color != null) {\n            this.context2d.strokeStyle = color;\n        }\n        // 線幅を設定する\n        this.context2d.lineWidth = width;\n        // パスの設定を開始することを明示する\n        this.context2d.beginPath();\n        // パスの始点を設定する\n        this.context2d.moveTo(x1, y1);\n        // 三次ベジェ曲線の制御点と終点を設定する\n        this.context2d.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n        // パスを閉じることを明示する\n        this.context2d.closePath();\n        // 設定したパスで線描画を行う\n        this.context2d.stroke();\n    }\n    /**\n     * テキストを描画する\n     * @param {string} text - 描画するテキスト\n     * @param {number} x - テキストを描画する位置の X 座標\n     * @param {number} y - テキストを描画する位置の Y 座標\n     * @param {string} [color] - テキストを描画する際の色\n     * @param {number} [width] - テキストを描画する幅に上限を設定する際の上限値(オプション)\n     */\n    drawText(text, x, y, color, width = 0) {\n        // 色が指定されている場合はスタイルを設定する\n        if (color != null) {\n            this.context2d.fillStyle = color;\n        }\n        if (width === 0) {\n            this.context2d.fillText(text, x, y);\n        }\n        else {\n            this.context2d.fillText(text, x, y, width);\n        }\n    }\n    /**\n     * 画像をロードしてコールバック関数にロードした画像を与え呼び出す\n     * @param {string} path - 画像ファイルのパス\n     * @param {function} [callback] - コールバック関数\n     */\n    imageLoader(path, callback) {\n        // 画像のインスタンスを生成する\n        let target = new Image();\n        // 画像がロード完了したときの処理を先に記述する\n        target.addEventListener('load', () => {\n            // もしコールバックがあれば呼び出す\n            if (callback != null) {\n                // コールバック関数の引数に画像を渡す\n                callback(target);\n            }\n        }, false);\n        // 画像のロードを開始するためにパスを指定する\n        target.src = path;\n    }\n}\nexports.Canvas2DUtility = Canvas2DUtility;\n\n\n//# sourceURL=webpack://reversi/./src/canvas2d.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst canvas2d_1 = __webpack_require__(/*! ./canvas2d */ \"./src/canvas2d.ts\");\nconst stones_1 = __webpack_require__(/*! ./stones */ \"./src/stones.ts\");\n//キーの押下状態を調べるためのオブジェクト\nwindow.isKeyDown = {};\n(() => {\n    //Canvas2D API をラップしたユーティリティクラス\n    let util = null;\n    //描画対象となる Canvas Element\n    let canvas = null;\n    //Canvas2D API のコンテキスト\n    let ctx = null;\n    let mainRequestID = null;\n    //canvas の幅\n    const CANVAS_WIDTH = 400;\n    //canvas の高さ\n    const CANVAS_HEIGHT = 400;\n    //マス目の数(8x8)\n    const GRID_NUM = 8;\n    //マス目1つのpixelサイズ\n    let grid_size = CANVAS_HEIGHT / GRID_NUM;\n    //石のインスタンス\n    let stones = null;\n    //ページのロードが完了したときに発火する load イベント\n    window.addEventListener('load', () => {\n        // ユーティリティクラスを初期化\n        util = new canvas2d_1.Canvas2DUtility(document.body.querySelector('#main_canvas'));\n        // ユーティリティクラスから canvas を取得\n        canvas = util.canvas;\n        // ユーティリティクラスから 2d コンテキストを取得\n        ctx = util.context;\n        // canvas の大きさを設定\n        canvas.width = CANVAS_WIDTH;\n        canvas.height = CANVAS_HEIGHT;\n        //石のインスタンスを作成\n        stones = new stones_1.Stones(util, GRID_NUM, grid_size);\n        // イベントを設定する\n        eventSetting();\n        //ループ処理\n        update();\n    }, false);\n    //イベントを設定する\n    function eventSetting() {\n        // キーの押下時に呼び出されるイベントリスナーを設定する\n        window.addEventListener('keydown', (event) => {\n            // キーの押下状態を管理するオブジェクトに押下されたことを設定する\n            window.isKeyDown[`key_${event.key}`] = true;\n            //スペースの場合\n            if (event.key === ' ') {\n                // キーの押下状態を管理するオブジェクトに押下されたことを設定する\n                window.isKeyDown['key_Space'] = true;\n                console.log('スペースキー押されてるよ');\n            }\n        }, false);\n        // キーが離された時に呼び出されるイベントリスナーを設定する\n        window.addEventListener('keyup', (event) => {\n            // キーが離されたことを設定する\n            window.isKeyDown[`key_${event.key}`] = false;\n            //スペースの場合\n            if (event.key === ' ') {\n                // キーの押下状態を管理するオブジェクトに押下されたことを設定する\n                window.isKeyDown['key_Space'] = false;\n            }\n        }, false);\n    }\n    //盤面を描画\n    function draw_board() {\n        // 画面を背景色で塗りつぶす\n        util.drawRect(0, 0, canvas.width, canvas.height, '#99ee99');\n        //盤面の線を描画\n        for (let i = 0; i <= GRID_NUM; i++) {\n            util.drawLine(0, grid_size * i, CANVAS_HEIGHT, grid_size * i, \"black\");\n            util.drawLine(grid_size * i, 0, grid_size * i, CANVAS_HEIGHT, \"black\");\n        }\n    }\n    //処理を行う\n    function update() {\n        //ゲーム実行\n        // グローバルなアルファを必ず 1.0 で描画処理を開始する\n        ctx.globalAlpha = 1.0;\n        //盤を描画\n        draw_board();\n        //石の処理\n        stones.update();\n        // 恒常ループのために描画処理を再帰呼出しする\n        mainRequestID = requestAnimationFrame(update);\n    }\n})();\n\n\n//# sourceURL=webpack://reversi/./src/main.ts?");

/***/ }),

/***/ "./src/stones.ts":
/*!***********************!*\
  !*** ./src/stones.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Stones = void 0;\nclass Stones {\n    constructor(util, stone_num, grid_size) {\n        this.util = util;\n        //盤面に石が無い状態で初期化\n        //stone[y][x]\n        this.stone = Array.from(new Array(stone_num), () => new Array(stone_num).fill(0));\n        //真ん中の4つに石を配置\n        this.stone[3][3] = 1;\n        this.stone[3][4] = -1;\n        this.stone[4][3] = -1;\n        this.stone[4][4] = 1;\n        this.stone_num = stone_num;\n        this.grid_size = grid_size;\n        //直径はマス目の80%の大きさとする\n        this.stone_radius = grid_size * 0.8 * 0.5;\n    }\n    update() {\n        this.draw();\n    }\n    draw() {\n        for (let y = 0; y < this.stone_num; ++y) {\n            for (let x = 0; x < this.stone_num; ++x) {\n                this.draw_stone(x, y, this.stone[y][x]);\n            }\n        }\n    }\n    //指定されたマス目の石を描画\n    draw_stone(x, y, status) {\n        //石が置かれていなければ何もしない\n        if (status == 0)\n            return;\n        let color = status > 0 ? \"black\" : \"white\";\n        this.util.drawCircle((0.5 + x) * this.grid_size, (0.5 + y) * this.grid_size, this.stone_radius, color);\n    }\n}\nexports.Stones = Stones;\n\n\n//# sourceURL=webpack://reversi/./src/stones.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;